using System;
using System.Diagnostics;

namespace GrammlatorExamples {
   static class TerminalSymbols2ndExample {
      public static Boolean AnalyzeInput(string line)
      {
         // This example uses C# constants to implement the terminal symbols.
         // The weird naming and assignment of values demonstrates that there
         // is no special handling of characters implemented in grammlator
         const int a = 11, b = 9, cLetter = 23, d = 24, MyOther = 99;

         line += '*'; // append '*' to mark the end of the line
         int i = 0;

         int MyPeek() =>
            line[i] switch { 'a' => a, 'b' => b, 'c' => cLetter, 'd' => d, _ => MyOther };

         // Local method "DisplayRemainder()":
         // one call has to be generated by grammlator (see "ErrorHaltInstruction):...")
         // the second call has been programmed below after "#endregion grammlator generated""
         void DisplayRemainder()
             => Console.WriteLine($@" Remainder of line: ""{line[i..]}""");

         #region grammar
         //| InputExpression: "MyPeek()";
         //| InputAcceptInstruction: "i++;";
         //| ErrorHaltInstruction: "DisplayRemainder(); return false;";
         //|
         //| // Declaration of the terminal symbols without enum:
         //| b | a | cLetter | d; // must be sorted by value!
         //|
         //| *= a | d, cLetter, b | d, b, cLetter ;
         #endregion grammar

#region grammlator generated 23 Mar 2023 (grammlator file version/date 2022.11.10.0/17 Jan 2023)

  // State1:
  /* *Startsymbol= ►a;
   * *Startsymbol= ►d, cLetter, b;
   * *Startsymbol= ►d, b, cLetter; */
  if (MyPeek() == d)
     {
     i++;
     // State2:
     /* *Startsymbol= d, ►cLetter, b;
      * *Startsymbol= d, ►b, cLetter; */
     if (MyPeek() == b)
        {
        i++;
        // State4:
        /* *Startsymbol= d, b, ►cLetter; */
        if (MyPeek() != cLetter)
           goto EndWithError;
        Debug.Assert(MyPeek() == cLetter);
        goto AcceptEndOfGeneratedCode;
        }
     if (MyPeek() != cLetter)
        goto EndWithError;
     Debug.Assert(MyPeek() == cLetter);
     i++;
     // State3:
     /* *Startsymbol= d, cLetter, ►b; */
     if (MyPeek() != b)
        goto EndWithError;
     Debug.Assert(MyPeek() == b);
     goto AcceptEndOfGeneratedCode;
     }
  if (MyPeek() != a)
     goto EndWithError;
  Debug.Assert(MyPeek() == a);
AcceptEndOfGeneratedCode:
  i++;
  goto EndOfGeneratedCode;

EndWithError:
  // This point is reached after an input error has been found
  DisplayRemainder(); return false;
EndOfGeneratedCode:
  ;

#endregion grammlator generated 23 Mar 2023 (grammlator file version/date 2022.11.10.0/17 Jan 2023)
         DisplayRemainder();
         return true;
      }
   }
}
