

## 1. Introduction

Welcome to the grammar translator "grammlator". Grammlator is a software tool and assists programmers who want to write applications that analyze input streams. So grammlator is a special "program generator",  "a  computer  program  that  can  be  used  to  help  to  create  other  computer  programs"[^2].

Grammlator may also be of interest to students who want to try out examples of LR-parsing. Typing in a grammar, clicking translate, perhaps correcting some typos, will  list the symbols, the conflicts, and the states and parser actions (before and after optimization). And even the optimized code generated by grammlator gives an impression, how LR-parsing may work.

But the main purpose of  grammlator is to assist programmers. The programmer describes the structure of the input data using a grammar and applies the principles of "Syntax directed translation"[^4] to write a program, that analyzes a stream of data elements. This is done by adding attributes and C#-methods to the grammar rules, embedding this combination as a region into a C# program file and let grammlator add (or replace) the lines of another region of the same file with generated code. The objective is to get a well structured and documented program, which can be maintained using Visual Studio (or other C# development tools) and grammlator.

This version of grammlator produces an LALR(1) parser. Reading this manual you may get an idea of the concept of grammars and of states and actions of an analyzer.  The basics and the limitations of LALR(1) parsing are well known and well documented [^7]and you will find precise information in manifold literature and in the internet. 

Grammlator has some unique features:

- Most of the examples in this manual analyze streams of characters. But grammlator does not contain a concept of "character" and even less a concept of "string". It handles abstract "terminal symbols" and sequences of terminal symbols. The C# implementation of each terminal symbol is a C# constant defined by the programmer. Typically they are elements of a C# enum. The examples show some ways how a programmer can map characters to such constants by simple C# instructions or methods.
- Grammlator does not build syntax trees. It "only" generates a sequence of instructions which test terminal symbols and call the C# methods written by the programmer. The programmer may use this methods to generate syntax trees.
- The syntax of the grammar rules is alike "Extended Backus-Naur Form"[^5]. Comments in the grammar part are like C# comments, attributes look like C# formal parameters.
- The semantic attributes, which can be assigned to terminal and nonterminal symbols are strongly typed by using names of C# value or C# reference types. Even user defined types (classes, structs) are allowed. Grammlator does know nothing of these types. It simply checks the equality of the names.
- Grammlator produces C# code. To produce code is common practice in implementing top-down-parsers, but unusual and not trivial in implementing bottom-up-algorithms. (Most implementations of bottom-up-methods use interpreters and tables).
- Grammlator produces optimized code which in simple cases even does not use a state stack.
- As an option grammlator inserts comments (typically the kernel items of the states and the applied grammar rules) into the generated code.
- The programmer may give a static priority (a number) or a dynamic priority (an int method) to each grammar rule. Grammlator uses this priorities to solve shift-reduce and reduce-reduce-conflicts in ambiguous grammars.
- Grammlator has no special options to produce a lexer or a parser. But it offers support to use syntax directed programing when writing a class, which implements special methods (Peek(), Accept() ...) and which can be used by another method to get its terminal symbols.




Links to all Chapters:

 ## 0. [Abstract](C00-Grammlator-Manual)
 ## 1. [Introduction](C01-Introduction.md)
 ## 2. [The Grammlator Application](C02-The-Grammlator-Application.md)
 ## 3. [Structure of the grammlator input (C# source file)](C03-Structure-of-the-grammlator-input.md) 
 ## 4. [Basic Grammlator settings](C04-Basic-Grammlator-Settings.md)
 ## 5. [Declare Terminal symbols](C05-Declare-Terminal-Symbols.md)

 To be added later:
 ## 6. Define the startsymbol and other nonterminal symbols
 ### ... sequence of symbols (definition, alternative), priority, method
 ### ... sequence of definitions, optional semicolon
 ## 7. Use Recursion
 ## 8. Semantic Attributes
 ### Types
 ### Stack 
 ### Assignment by overlay
 ### Usage and assignment by methods
 ## 9. Syntactic sugar: repeat operators
 ## 10. Solve Conflicts
 ## 11. Advanced
 ### 1st and last terminal symbol
 ### Compiler Settings

## 99.  [Appendix](C99-Appendix.md)